// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: authentication.proto

package bass_original

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Constant_ErrorCode int32

const (
	// Error Code Range 10000000 - 10100000
	Constant_ERROR_INVALID_SSO_TOKEN         Constant_ErrorCode = 10000000
	Constant_ERROR_INVALID_TOKEN             Constant_ErrorCode = 10000001
	Constant_ERROR_INVALID_USER_STATUS       Constant_ErrorCode = 10000002
	Constant_ERROR_EXPIRED_SSO_TOKEN         Constant_ErrorCode = 10000003
	Constant_ERROR_INVALID_CORE_SERVER_TOKEN Constant_ErrorCode = 10000004
	Constant_ERROR_EMPTY_TOKEN               Constant_ErrorCode = 10000005
	Constant_ERROR_UNMATCHED_TOKEN           Constant_ErrorCode = 10000006
	Constant_ERROR_INVALID_USER_ID           Constant_ErrorCode = 10000007
	Constant_ERROR_USER_KICKED_OUT           Constant_ErrorCode = 10000008
	Constant_ERROR_INVALID_KICKOUT_SIGNATURE Constant_ErrorCode = 10000009
	Constant_ERROR_MISSING_KICKOUT_CONFIG    Constant_ErrorCode = 10000010
	Constant_ERROR_UPSTREAM                  Constant_ErrorCode = 10000011
	Constant_ERROR_INTERNAL                  Constant_ErrorCode = 10000012
	Constant_ERROR_CLEAR_TOKEN_CACHE         Constant_ErrorCode = 10000013
	Constant_ERROR_HEALTH_CHECK_CACHE_CLOUD  Constant_ErrorCode = 10099001
)

var Constant_ErrorCode_name = map[int32]string{
	10000000: "ERROR_INVALID_SSO_TOKEN",
	10000001: "ERROR_INVALID_TOKEN",
	10000002: "ERROR_INVALID_USER_STATUS",
	10000003: "ERROR_EXPIRED_SSO_TOKEN",
	10000004: "ERROR_INVALID_CORE_SERVER_TOKEN",
	10000005: "ERROR_EMPTY_TOKEN",
	10000006: "ERROR_UNMATCHED_TOKEN",
	10000007: "ERROR_INVALID_USER_ID",
	10000008: "ERROR_USER_KICKED_OUT",
	10000009: "ERROR_INVALID_KICKOUT_SIGNATURE",
	10000010: "ERROR_MISSING_KICKOUT_CONFIG",
	10000011: "ERROR_UPSTREAM",
	10000012: "ERROR_INTERNAL",
	10000013: "ERROR_CLEAR_TOKEN_CACHE",
	10099001: "ERROR_HEALTH_CHECK_CACHE_CLOUD",
}

var Constant_ErrorCode_value = map[string]int32{
	"ERROR_INVALID_SSO_TOKEN":         10000000,
	"ERROR_INVALID_TOKEN":             10000001,
	"ERROR_INVALID_USER_STATUS":       10000002,
	"ERROR_EXPIRED_SSO_TOKEN":         10000003,
	"ERROR_INVALID_CORE_SERVER_TOKEN": 10000004,
	"ERROR_EMPTY_TOKEN":               10000005,
	"ERROR_UNMATCHED_TOKEN":           10000006,
	"ERROR_INVALID_USER_ID":           10000007,
	"ERROR_USER_KICKED_OUT":           10000008,
	"ERROR_INVALID_KICKOUT_SIGNATURE": 10000009,
	"ERROR_MISSING_KICKOUT_CONFIG":    10000010,
	"ERROR_UPSTREAM":                  10000011,
	"ERROR_INTERNAL":                  10000012,
	"ERROR_CLEAR_TOKEN_CACHE":         10000013,
	"ERROR_HEALTH_CHECK_CACHE_CLOUD":  10099001,
}

func (x Constant_ErrorCode) Enum() *Constant_ErrorCode {
	p := new(Constant_ErrorCode)
	*p = x
	return p
}

func (x Constant_ErrorCode) String() string {
	return proto.EnumName(Constant_ErrorCode_name, int32(x))
}

func (x *Constant_ErrorCode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Constant_ErrorCode_value, data, "Constant_ErrorCode")
	if err != nil {
		return err
	}
	*x = Constant_ErrorCode(value)
	return nil
}

func (Constant_ErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{0, 0}
}

type Constant struct {
}

func (m *Constant) Reset()         { *m = Constant{} }
func (m *Constant) String() string { return proto.CompactTextString(m) }
func (*Constant) ProtoMessage()    {}
func (*Constant) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{0}
}
func (m *Constant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Constant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Constant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Constant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Constant.Merge(m, src)
}
func (m *Constant) XXX_Size() int {
	return m.Size()
}
func (m *Constant) XXX_DiscardUnknown() {
	xxx_messageInfo_Constant.DiscardUnknown(m)
}

var xxx_messageInfo_Constant proto.InternalMessageInfo

type EchoRequest struct {
	Data uint64 `protobuf:"varint,1,opt,name=data" json:"data"`
}

func (m *EchoRequest) Reset()         { *m = EchoRequest{} }
func (m *EchoRequest) String() string { return proto.CompactTextString(m) }
func (*EchoRequest) ProtoMessage()    {}
func (*EchoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{1}
}
func (m *EchoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EchoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EchoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EchoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EchoRequest.Merge(m, src)
}
func (m *EchoRequest) XXX_Size() int {
	return m.Size()
}
func (m *EchoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EchoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EchoRequest proto.InternalMessageInfo

func (m *EchoRequest) GetData() uint64 {
	if m != nil {
		return m.Data
	}
	return 0
}

type EchoResponse struct {
	Data uint64 `protobuf:"varint,1,opt,name=data" json:"data"`
}

func (m *EchoResponse) Reset()         { *m = EchoResponse{} }
func (m *EchoResponse) String() string { return proto.CompactTextString(m) }
func (*EchoResponse) ProtoMessage()    {}
func (*EchoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{2}
}
func (m *EchoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EchoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EchoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EchoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EchoResponse.Merge(m, src)
}
func (m *EchoResponse) XXX_Size() int {
	return m.Size()
}
func (m *EchoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EchoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EchoResponse proto.InternalMessageInfo

func (m *EchoResponse) GetData() uint64 {
	if m != nil {
		return m.Data
	}
	return 0
}

type VerifyEncryptedTokenRequest struct {
	EncryptedToken string `protobuf:"bytes,1,opt,name=encrypted_token,json=encryptedToken" json:"encrypted_token"`
}

func (m *VerifyEncryptedTokenRequest) Reset()         { *m = VerifyEncryptedTokenRequest{} }
func (m *VerifyEncryptedTokenRequest) String() string { return proto.CompactTextString(m) }
func (*VerifyEncryptedTokenRequest) ProtoMessage()    {}
func (*VerifyEncryptedTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{3}
}
func (m *VerifyEncryptedTokenRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyEncryptedTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyEncryptedTokenRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyEncryptedTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyEncryptedTokenRequest.Merge(m, src)
}
func (m *VerifyEncryptedTokenRequest) XXX_Size() int {
	return m.Size()
}
func (m *VerifyEncryptedTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyEncryptedTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyEncryptedTokenRequest proto.InternalMessageInfo

func (m *VerifyEncryptedTokenRequest) GetEncryptedToken() string {
	if m != nil {
		return m.EncryptedToken
	}
	return ""
}

type VerifyEncryptedTokenResponse struct {
	Token    string `protobuf:"bytes,1,opt,name=token" json:"token"`
	UserId   int32  `protobuf:"varint,2,opt,name=user_id,json=userId" json:"user_id"`
	ShopId   int32  `protobuf:"varint,3,opt,name=shop_id,json=shopId" json:"shop_id"`
	UserName string `protobuf:"bytes,4,opt,name=user_name,json=userName" json:"user_name"`
	Email    string `protobuf:"bytes,5,opt,name=email" json:"email"`
	Status   int32  `protobuf:"varint,6,opt,name=status" json:"status"`
}

func (m *VerifyEncryptedTokenResponse) Reset()         { *m = VerifyEncryptedTokenResponse{} }
func (m *VerifyEncryptedTokenResponse) String() string { return proto.CompactTextString(m) }
func (*VerifyEncryptedTokenResponse) ProtoMessage()    {}
func (*VerifyEncryptedTokenResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{4}
}
func (m *VerifyEncryptedTokenResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyEncryptedTokenResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyEncryptedTokenResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyEncryptedTokenResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyEncryptedTokenResponse.Merge(m, src)
}
func (m *VerifyEncryptedTokenResponse) XXX_Size() int {
	return m.Size()
}
func (m *VerifyEncryptedTokenResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyEncryptedTokenResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyEncryptedTokenResponse proto.InternalMessageInfo

func (m *VerifyEncryptedTokenResponse) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *VerifyEncryptedTokenResponse) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *VerifyEncryptedTokenResponse) GetShopId() int32 {
	if m != nil {
		return m.ShopId
	}
	return 0
}

func (m *VerifyEncryptedTokenResponse) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *VerifyEncryptedTokenResponse) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *VerifyEncryptedTokenResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type UnpackEncryptedTokenRequest struct {
	EncryptedToken     string `protobuf:"bytes,1,opt,name=encrypted_token,json=encryptedToken" json:"encrypted_token"`
	DisableExpiryCheck bool   `protobuf:"varint,2,opt,name=disable_expiry_check,json=disableExpiryCheck" json:"disable_expiry_check"`
}

func (m *UnpackEncryptedTokenRequest) Reset()         { *m = UnpackEncryptedTokenRequest{} }
func (m *UnpackEncryptedTokenRequest) String() string { return proto.CompactTextString(m) }
func (*UnpackEncryptedTokenRequest) ProtoMessage()    {}
func (*UnpackEncryptedTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{5}
}
func (m *UnpackEncryptedTokenRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnpackEncryptedTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnpackEncryptedTokenRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnpackEncryptedTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnpackEncryptedTokenRequest.Merge(m, src)
}
func (m *UnpackEncryptedTokenRequest) XXX_Size() int {
	return m.Size()
}
func (m *UnpackEncryptedTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnpackEncryptedTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnpackEncryptedTokenRequest proto.InternalMessageInfo

func (m *UnpackEncryptedTokenRequest) GetEncryptedToken() string {
	if m != nil {
		return m.EncryptedToken
	}
	return ""
}

func (m *UnpackEncryptedTokenRequest) GetDisableExpiryCheck() bool {
	if m != nil {
		return m.DisableExpiryCheck
	}
	return false
}

type UnpackEncryptedTokenResponse struct {
	Token    string `protobuf:"bytes,1,opt,name=token" json:"token"`
	UserId   int32  `protobuf:"varint,2,opt,name=user_id,json=userId" json:"user_id"`
	ShopId   int32  `protobuf:"varint,3,opt,name=shop_id,json=shopId" json:"shop_id"`
	UserName string `protobuf:"bytes,4,opt,name=user_name,json=userName" json:"user_name"`
}

func (m *UnpackEncryptedTokenResponse) Reset()         { *m = UnpackEncryptedTokenResponse{} }
func (m *UnpackEncryptedTokenResponse) String() string { return proto.CompactTextString(m) }
func (*UnpackEncryptedTokenResponse) ProtoMessage()    {}
func (*UnpackEncryptedTokenResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{6}
}
func (m *UnpackEncryptedTokenResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnpackEncryptedTokenResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnpackEncryptedTokenResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnpackEncryptedTokenResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnpackEncryptedTokenResponse.Merge(m, src)
}
func (m *UnpackEncryptedTokenResponse) XXX_Size() int {
	return m.Size()
}
func (m *UnpackEncryptedTokenResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnpackEncryptedTokenResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnpackEncryptedTokenResponse proto.InternalMessageInfo

func (m *UnpackEncryptedTokenResponse) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *UnpackEncryptedTokenResponse) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UnpackEncryptedTokenResponse) GetShopId() int32 {
	if m != nil {
		return m.ShopId
	}
	return 0
}

func (m *UnpackEncryptedTokenResponse) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

type GetUserInfoFromTokenRequest struct {
	EncryptedToken string `protobuf:"bytes,1,opt,name=encrypted_token,json=encryptedToken" json:"encrypted_token"`
	ShopeeToken    string `protobuf:"bytes,2,opt,name=shopee_token,json=shopeeToken" json:"shopee_token"`
}

func (m *GetUserInfoFromTokenRequest) Reset()         { *m = GetUserInfoFromTokenRequest{} }
func (m *GetUserInfoFromTokenRequest) String() string { return proto.CompactTextString(m) }
func (*GetUserInfoFromTokenRequest) ProtoMessage()    {}
func (*GetUserInfoFromTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{7}
}
func (m *GetUserInfoFromTokenRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUserInfoFromTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUserInfoFromTokenRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUserInfoFromTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUserInfoFromTokenRequest.Merge(m, src)
}
func (m *GetUserInfoFromTokenRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetUserInfoFromTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUserInfoFromTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetUserInfoFromTokenRequest proto.InternalMessageInfo

func (m *GetUserInfoFromTokenRequest) GetEncryptedToken() string {
	if m != nil {
		return m.EncryptedToken
	}
	return ""
}

func (m *GetUserInfoFromTokenRequest) GetShopeeToken() string {
	if m != nil {
		return m.ShopeeToken
	}
	return ""
}

type GetUserInfoFromTokenResponse struct {
	Token    string `protobuf:"bytes,1,opt,name=token" json:"token"`
	UserId   int32  `protobuf:"varint,2,opt,name=user_id,json=userId" json:"user_id"`
	ShopId   int32  `protobuf:"varint,3,opt,name=shop_id,json=shopId" json:"shop_id"`
	UserName string `protobuf:"bytes,4,opt,name=user_name,json=userName" json:"user_name"`
	Email    string `protobuf:"bytes,5,opt,name=email" json:"email"`
	Status   int32  `protobuf:"varint,6,opt,name=status" json:"status"`
}

func (m *GetUserInfoFromTokenResponse) Reset()         { *m = GetUserInfoFromTokenResponse{} }
func (m *GetUserInfoFromTokenResponse) String() string { return proto.CompactTextString(m) }
func (*GetUserInfoFromTokenResponse) ProtoMessage()    {}
func (*GetUserInfoFromTokenResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{8}
}
func (m *GetUserInfoFromTokenResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetUserInfoFromTokenResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetUserInfoFromTokenResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetUserInfoFromTokenResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetUserInfoFromTokenResponse.Merge(m, src)
}
func (m *GetUserInfoFromTokenResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetUserInfoFromTokenResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetUserInfoFromTokenResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetUserInfoFromTokenResponse proto.InternalMessageInfo

func (m *GetUserInfoFromTokenResponse) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *GetUserInfoFromTokenResponse) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GetUserInfoFromTokenResponse) GetShopId() int32 {
	if m != nil {
		return m.ShopId
	}
	return 0
}

func (m *GetUserInfoFromTokenResponse) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *GetUserInfoFromTokenResponse) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *GetUserInfoFromTokenResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type GenerateEncryptedTokenRequest struct {
	Token    string `protobuf:"bytes,1,opt,name=token" json:"token"`
	UserId   int32  `protobuf:"varint,2,opt,name=user_id,json=userId" json:"user_id"`
	ShopId   int32  `protobuf:"varint,3,opt,name=shop_id,json=shopId" json:"shop_id"`
	UserName string `protobuf:"bytes,4,opt,name=user_name,json=userName" json:"user_name"`
}

func (m *GenerateEncryptedTokenRequest) Reset()         { *m = GenerateEncryptedTokenRequest{} }
func (m *GenerateEncryptedTokenRequest) String() string { return proto.CompactTextString(m) }
func (*GenerateEncryptedTokenRequest) ProtoMessage()    {}
func (*GenerateEncryptedTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{9}
}
func (m *GenerateEncryptedTokenRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenerateEncryptedTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenerateEncryptedTokenRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenerateEncryptedTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateEncryptedTokenRequest.Merge(m, src)
}
func (m *GenerateEncryptedTokenRequest) XXX_Size() int {
	return m.Size()
}
func (m *GenerateEncryptedTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateEncryptedTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateEncryptedTokenRequest proto.InternalMessageInfo

func (m *GenerateEncryptedTokenRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *GenerateEncryptedTokenRequest) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GenerateEncryptedTokenRequest) GetShopId() int32 {
	if m != nil {
		return m.ShopId
	}
	return 0
}

func (m *GenerateEncryptedTokenRequest) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

type GenerateEncryptedTokenResponse struct {
	EncryptedToken string `protobuf:"bytes,1,opt,name=encrypted_token,json=encryptedToken" json:"encrypted_token"`
}

func (m *GenerateEncryptedTokenResponse) Reset()         { *m = GenerateEncryptedTokenResponse{} }
func (m *GenerateEncryptedTokenResponse) String() string { return proto.CompactTextString(m) }
func (*GenerateEncryptedTokenResponse) ProtoMessage()    {}
func (*GenerateEncryptedTokenResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{10}
}
func (m *GenerateEncryptedTokenResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenerateEncryptedTokenResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenerateEncryptedTokenResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenerateEncryptedTokenResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateEncryptedTokenResponse.Merge(m, src)
}
func (m *GenerateEncryptedTokenResponse) XXX_Size() int {
	return m.Size()
}
func (m *GenerateEncryptedTokenResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateEncryptedTokenResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateEncryptedTokenResponse proto.InternalMessageInfo

func (m *GenerateEncryptedTokenResponse) GetEncryptedToken() string {
	if m != nil {
		return m.EncryptedToken
	}
	return ""
}

type KickOutUserRequest struct {
	UserId int32  `protobuf:"varint,1,opt,name=user_id,json=userId" json:"user_id"`
	Sig    string `protobuf:"bytes,2,opt,name=sig" json:"sig"`
}

func (m *KickOutUserRequest) Reset()         { *m = KickOutUserRequest{} }
func (m *KickOutUserRequest) String() string { return proto.CompactTextString(m) }
func (*KickOutUserRequest) ProtoMessage()    {}
func (*KickOutUserRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{11}
}
func (m *KickOutUserRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KickOutUserRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KickOutUserRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KickOutUserRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KickOutUserRequest.Merge(m, src)
}
func (m *KickOutUserRequest) XXX_Size() int {
	return m.Size()
}
func (m *KickOutUserRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_KickOutUserRequest.DiscardUnknown(m)
}

var xxx_messageInfo_KickOutUserRequest proto.InternalMessageInfo

func (m *KickOutUserRequest) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *KickOutUserRequest) GetSig() string {
	if m != nil {
		return m.Sig
	}
	return ""
}

type KickOutUserResponse struct {
}

func (m *KickOutUserResponse) Reset()         { *m = KickOutUserResponse{} }
func (m *KickOutUserResponse) String() string { return proto.CompactTextString(m) }
func (*KickOutUserResponse) ProtoMessage()    {}
func (*KickOutUserResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{12}
}
func (m *KickOutUserResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KickOutUserResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KickOutUserResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KickOutUserResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KickOutUserResponse.Merge(m, src)
}
func (m *KickOutUserResponse) XXX_Size() int {
	return m.Size()
}
func (m *KickOutUserResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_KickOutUserResponse.DiscardUnknown(m)
}

var xxx_messageInfo_KickOutUserResponse proto.InternalMessageInfo

type ClearTokenVerificationCacheRequest struct {
	Token string `protobuf:"bytes,1,opt,name=token" json:"token"`
}

func (m *ClearTokenVerificationCacheRequest) Reset()         { *m = ClearTokenVerificationCacheRequest{} }
func (m *ClearTokenVerificationCacheRequest) String() string { return proto.CompactTextString(m) }
func (*ClearTokenVerificationCacheRequest) ProtoMessage()    {}
func (*ClearTokenVerificationCacheRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{13}
}
func (m *ClearTokenVerificationCacheRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearTokenVerificationCacheRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClearTokenVerificationCacheRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClearTokenVerificationCacheRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearTokenVerificationCacheRequest.Merge(m, src)
}
func (m *ClearTokenVerificationCacheRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClearTokenVerificationCacheRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearTokenVerificationCacheRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClearTokenVerificationCacheRequest proto.InternalMessageInfo

func (m *ClearTokenVerificationCacheRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type ClearTokenVerificationCacheResponse struct {
}

func (m *ClearTokenVerificationCacheResponse) Reset()         { *m = ClearTokenVerificationCacheResponse{} }
func (m *ClearTokenVerificationCacheResponse) String() string { return proto.CompactTextString(m) }
func (*ClearTokenVerificationCacheResponse) ProtoMessage()    {}
func (*ClearTokenVerificationCacheResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{14}
}
func (m *ClearTokenVerificationCacheResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearTokenVerificationCacheResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClearTokenVerificationCacheResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClearTokenVerificationCacheResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearTokenVerificationCacheResponse.Merge(m, src)
}
func (m *ClearTokenVerificationCacheResponse) XXX_Size() int {
	return m.Size()
}
func (m *ClearTokenVerificationCacheResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearTokenVerificationCacheResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ClearTokenVerificationCacheResponse proto.InternalMessageInfo

type GenerateEncryptedTobTokenRequest struct {
	TobToken      string `protobuf:"bytes,1,opt,name=tob_token,json=tobToken" json:"tob_token"`
	TobUserId     uint64 `protobuf:"varint,2,opt,name=tob_user_id,json=tobUserId" json:"tob_user_id"`
	TobBusinessId uint32 `protobuf:"varint,3,opt,name=tob_business_id,json=tobBusinessId" json:"tob_business_id"`
}

func (m *GenerateEncryptedTobTokenRequest) Reset()         { *m = GenerateEncryptedTobTokenRequest{} }
func (m *GenerateEncryptedTobTokenRequest) String() string { return proto.CompactTextString(m) }
func (*GenerateEncryptedTobTokenRequest) ProtoMessage()    {}
func (*GenerateEncryptedTobTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{15}
}
func (m *GenerateEncryptedTobTokenRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenerateEncryptedTobTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenerateEncryptedTobTokenRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenerateEncryptedTobTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateEncryptedTobTokenRequest.Merge(m, src)
}
func (m *GenerateEncryptedTobTokenRequest) XXX_Size() int {
	return m.Size()
}
func (m *GenerateEncryptedTobTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateEncryptedTobTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateEncryptedTobTokenRequest proto.InternalMessageInfo

func (m *GenerateEncryptedTobTokenRequest) GetTobToken() string {
	if m != nil {
		return m.TobToken
	}
	return ""
}

func (m *GenerateEncryptedTobTokenRequest) GetTobUserId() uint64 {
	if m != nil {
		return m.TobUserId
	}
	return 0
}

func (m *GenerateEncryptedTobTokenRequest) GetTobBusinessId() uint32 {
	if m != nil {
		return m.TobBusinessId
	}
	return 0
}

type GenerateEncryptedTobTokenResponse struct {
	EncryptedTobToken string `protobuf:"bytes,1,opt,name=encrypted_tob_token,json=encryptedTobToken" json:"encrypted_tob_token"`
	DebugMsg          string `protobuf:"bytes,2,opt,name=debug_msg,json=debugMsg" json:"debug_msg"`
}

func (m *GenerateEncryptedTobTokenResponse) Reset()         { *m = GenerateEncryptedTobTokenResponse{} }
func (m *GenerateEncryptedTobTokenResponse) String() string { return proto.CompactTextString(m) }
func (*GenerateEncryptedTobTokenResponse) ProtoMessage()    {}
func (*GenerateEncryptedTobTokenResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{16}
}
func (m *GenerateEncryptedTobTokenResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenerateEncryptedTobTokenResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenerateEncryptedTobTokenResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenerateEncryptedTobTokenResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerateEncryptedTobTokenResponse.Merge(m, src)
}
func (m *GenerateEncryptedTobTokenResponse) XXX_Size() int {
	return m.Size()
}
func (m *GenerateEncryptedTobTokenResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerateEncryptedTobTokenResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GenerateEncryptedTobTokenResponse proto.InternalMessageInfo

func (m *GenerateEncryptedTobTokenResponse) GetEncryptedTobToken() string {
	if m != nil {
		return m.EncryptedTobToken
	}
	return ""
}

func (m *GenerateEncryptedTobTokenResponse) GetDebugMsg() string {
	if m != nil {
		return m.DebugMsg
	}
	return ""
}

type UnpackEncryptedTobTokenRequest struct {
	EncryptedTobToken string `protobuf:"bytes,1,opt,name=encrypted_tob_token,json=encryptedTobToken" json:"encrypted_tob_token"`
	AppType           uint32 `protobuf:"varint,2,opt,name=app_type,json=appType" json:"app_type"`
}

func (m *UnpackEncryptedTobTokenRequest) Reset()         { *m = UnpackEncryptedTobTokenRequest{} }
func (m *UnpackEncryptedTobTokenRequest) String() string { return proto.CompactTextString(m) }
func (*UnpackEncryptedTobTokenRequest) ProtoMessage()    {}
func (*UnpackEncryptedTobTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{17}
}
func (m *UnpackEncryptedTobTokenRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnpackEncryptedTobTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnpackEncryptedTobTokenRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnpackEncryptedTobTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnpackEncryptedTobTokenRequest.Merge(m, src)
}
func (m *UnpackEncryptedTobTokenRequest) XXX_Size() int {
	return m.Size()
}
func (m *UnpackEncryptedTobTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnpackEncryptedTobTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnpackEncryptedTobTokenRequest proto.InternalMessageInfo

func (m *UnpackEncryptedTobTokenRequest) GetEncryptedTobToken() string {
	if m != nil {
		return m.EncryptedTobToken
	}
	return ""
}

func (m *UnpackEncryptedTobTokenRequest) GetAppType() uint32 {
	if m != nil {
		return m.AppType
	}
	return 0
}

type UnpackEncryptedTobTokenResponse struct {
	DebugMsg      string `protobuf:"bytes,1,opt,name=debug_msg,json=debugMsg" json:"debug_msg"`
	TobToken      string `protobuf:"bytes,2,opt,name=tob_token,json=tobToken" json:"tob_token"`
	TobUserId     uint64 `protobuf:"varint,3,opt,name=tob_user_id,json=tobUserId" json:"tob_user_id"`
	TobBusinessId uint32 `protobuf:"varint,4,opt,name=tob_business_id,json=tobBusinessId" json:"tob_business_id"`
}

func (m *UnpackEncryptedTobTokenResponse) Reset()         { *m = UnpackEncryptedTobTokenResponse{} }
func (m *UnpackEncryptedTobTokenResponse) String() string { return proto.CompactTextString(m) }
func (*UnpackEncryptedTobTokenResponse) ProtoMessage()    {}
func (*UnpackEncryptedTobTokenResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{18}
}
func (m *UnpackEncryptedTobTokenResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnpackEncryptedTobTokenResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnpackEncryptedTobTokenResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnpackEncryptedTobTokenResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnpackEncryptedTobTokenResponse.Merge(m, src)
}
func (m *UnpackEncryptedTobTokenResponse) XXX_Size() int {
	return m.Size()
}
func (m *UnpackEncryptedTobTokenResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnpackEncryptedTobTokenResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnpackEncryptedTobTokenResponse proto.InternalMessageInfo

func (m *UnpackEncryptedTobTokenResponse) GetDebugMsg() string {
	if m != nil {
		return m.DebugMsg
	}
	return ""
}

func (m *UnpackEncryptedTobTokenResponse) GetTobToken() string {
	if m != nil {
		return m.TobToken
	}
	return ""
}

func (m *UnpackEncryptedTobTokenResponse) GetTobUserId() uint64 {
	if m != nil {
		return m.TobUserId
	}
	return 0
}

func (m *UnpackEncryptedTobTokenResponse) GetTobBusinessId() uint32 {
	if m != nil {
		return m.TobBusinessId
	}
	return 0
}

type VerifyTobTokenRequest struct {
	TobToken string `protobuf:"bytes,1,opt,name=tob_token,json=tobToken" json:"tob_token"`
	AppType  uint32 `protobuf:"varint,2,opt,name=app_type,json=appType" json:"app_type"`
}

func (m *VerifyTobTokenRequest) Reset()         { *m = VerifyTobTokenRequest{} }
func (m *VerifyTobTokenRequest) String() string { return proto.CompactTextString(m) }
func (*VerifyTobTokenRequest) ProtoMessage()    {}
func (*VerifyTobTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{19}
}
func (m *VerifyTobTokenRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyTobTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyTobTokenRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyTobTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyTobTokenRequest.Merge(m, src)
}
func (m *VerifyTobTokenRequest) XXX_Size() int {
	return m.Size()
}
func (m *VerifyTobTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyTobTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyTobTokenRequest proto.InternalMessageInfo

func (m *VerifyTobTokenRequest) GetTobToken() string {
	if m != nil {
		return m.TobToken
	}
	return ""
}

func (m *VerifyTobTokenRequest) GetAppType() uint32 {
	if m != nil {
		return m.AppType
	}
	return 0
}

type VerifyTobTokenResponse struct {
	DebugMsg      string `protobuf:"bytes,1,opt,name=debug_msg,json=debugMsg" json:"debug_msg"`
	TobUserId     uint64 `protobuf:"varint,2,opt,name=tob_user_id,json=tobUserId" json:"tob_user_id"`
	TobBusinessId uint32 `protobuf:"varint,3,opt,name=tob_business_id,json=tobBusinessId" json:"tob_business_id"`
}

func (m *VerifyTobTokenResponse) Reset()         { *m = VerifyTobTokenResponse{} }
func (m *VerifyTobTokenResponse) String() string { return proto.CompactTextString(m) }
func (*VerifyTobTokenResponse) ProtoMessage()    {}
func (*VerifyTobTokenResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{20}
}
func (m *VerifyTobTokenResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyTobTokenResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyTobTokenResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyTobTokenResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyTobTokenResponse.Merge(m, src)
}
func (m *VerifyTobTokenResponse) XXX_Size() int {
	return m.Size()
}
func (m *VerifyTobTokenResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyTobTokenResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyTobTokenResponse proto.InternalMessageInfo

func (m *VerifyTobTokenResponse) GetDebugMsg() string {
	if m != nil {
		return m.DebugMsg
	}
	return ""
}

func (m *VerifyTobTokenResponse) GetTobUserId() uint64 {
	if m != nil {
		return m.TobUserId
	}
	return 0
}

func (m *VerifyTobTokenResponse) GetTobBusinessId() uint32 {
	if m != nil {
		return m.TobBusinessId
	}
	return 0
}

type KickOutTobUserRequest struct {
	TobUserId uint64 `protobuf:"varint,1,opt,name=tob_user_id,json=tobUserId" json:"tob_user_id"`
	Sig       string `protobuf:"bytes,2,opt,name=sig" json:"sig"`
}

func (m *KickOutTobUserRequest) Reset()         { *m = KickOutTobUserRequest{} }
func (m *KickOutTobUserRequest) String() string { return proto.CompactTextString(m) }
func (*KickOutTobUserRequest) ProtoMessage()    {}
func (*KickOutTobUserRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{21}
}
func (m *KickOutTobUserRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KickOutTobUserRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KickOutTobUserRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KickOutTobUserRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KickOutTobUserRequest.Merge(m, src)
}
func (m *KickOutTobUserRequest) XXX_Size() int {
	return m.Size()
}
func (m *KickOutTobUserRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_KickOutTobUserRequest.DiscardUnknown(m)
}

var xxx_messageInfo_KickOutTobUserRequest proto.InternalMessageInfo

func (m *KickOutTobUserRequest) GetTobUserId() uint64 {
	if m != nil {
		return m.TobUserId
	}
	return 0
}

func (m *KickOutTobUserRequest) GetSig() string {
	if m != nil {
		return m.Sig
	}
	return ""
}

type KickOutTobUserResponse struct {
	DebugMsg string `protobuf:"bytes,1,opt,name=debug_msg,json=debugMsg" json:"debug_msg"`
}

func (m *KickOutTobUserResponse) Reset()         { *m = KickOutTobUserResponse{} }
func (m *KickOutTobUserResponse) String() string { return proto.CompactTextString(m) }
func (*KickOutTobUserResponse) ProtoMessage()    {}
func (*KickOutTobUserResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{22}
}
func (m *KickOutTobUserResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KickOutTobUserResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KickOutTobUserResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KickOutTobUserResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KickOutTobUserResponse.Merge(m, src)
}
func (m *KickOutTobUserResponse) XXX_Size() int {
	return m.Size()
}
func (m *KickOutTobUserResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_KickOutTobUserResponse.DiscardUnknown(m)
}

var xxx_messageInfo_KickOutTobUserResponse proto.InternalMessageInfo

func (m *KickOutTobUserResponse) GetDebugMsg() string {
	if m != nil {
		return m.DebugMsg
	}
	return ""
}

type ClearTobTokenVerificationCacheRequest struct {
	TobToken string `protobuf:"bytes,1,opt,name=tob_token,json=tobToken" json:"tob_token"`
}

func (m *ClearTobTokenVerificationCacheRequest) Reset()         { *m = ClearTobTokenVerificationCacheRequest{} }
func (m *ClearTobTokenVerificationCacheRequest) String() string { return proto.CompactTextString(m) }
func (*ClearTobTokenVerificationCacheRequest) ProtoMessage()    {}
func (*ClearTobTokenVerificationCacheRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{23}
}
func (m *ClearTobTokenVerificationCacheRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearTobTokenVerificationCacheRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClearTobTokenVerificationCacheRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClearTobTokenVerificationCacheRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearTobTokenVerificationCacheRequest.Merge(m, src)
}
func (m *ClearTobTokenVerificationCacheRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClearTobTokenVerificationCacheRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearTobTokenVerificationCacheRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClearTobTokenVerificationCacheRequest proto.InternalMessageInfo

func (m *ClearTobTokenVerificationCacheRequest) GetTobToken() string {
	if m != nil {
		return m.TobToken
	}
	return ""
}

type ClearTobTokenVerificationCacheResponse struct {
	DebugMsg string `protobuf:"bytes,1,opt,name=debug_msg,json=debugMsg" json:"debug_msg"`
}

func (m *ClearTobTokenVerificationCacheResponse) Reset() {
	*m = ClearTobTokenVerificationCacheResponse{}
}
func (m *ClearTobTokenVerificationCacheResponse) String() string { return proto.CompactTextString(m) }
func (*ClearTobTokenVerificationCacheResponse) ProtoMessage()    {}
func (*ClearTobTokenVerificationCacheResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{24}
}
func (m *ClearTobTokenVerificationCacheResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearTobTokenVerificationCacheResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClearTobTokenVerificationCacheResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClearTobTokenVerificationCacheResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearTobTokenVerificationCacheResponse.Merge(m, src)
}
func (m *ClearTobTokenVerificationCacheResponse) XXX_Size() int {
	return m.Size()
}
func (m *ClearTobTokenVerificationCacheResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearTobTokenVerificationCacheResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ClearTobTokenVerificationCacheResponse proto.InternalMessageInfo

func (m *ClearTobTokenVerificationCacheResponse) GetDebugMsg() string {
	if m != nil {
		return m.DebugMsg
	}
	return ""
}

type HealthCheckRequest struct {
}

func (m *HealthCheckRequest) Reset()         { *m = HealthCheckRequest{} }
func (m *HealthCheckRequest) String() string { return proto.CompactTextString(m) }
func (*HealthCheckRequest) ProtoMessage()    {}
func (*HealthCheckRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{25}
}
func (m *HealthCheckRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HealthCheckRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HealthCheckRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HealthCheckRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HealthCheckRequest.Merge(m, src)
}
func (m *HealthCheckRequest) XXX_Size() int {
	return m.Size()
}
func (m *HealthCheckRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HealthCheckRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HealthCheckRequest proto.InternalMessageInfo

type HealthCheckResponse struct {
}

func (m *HealthCheckResponse) Reset()         { *m = HealthCheckResponse{} }
func (m *HealthCheckResponse) String() string { return proto.CompactTextString(m) }
func (*HealthCheckResponse) ProtoMessage()    {}
func (*HealthCheckResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0dbc99083440df2, []int{26}
}
func (m *HealthCheckResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HealthCheckResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HealthCheckResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HealthCheckResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HealthCheckResponse.Merge(m, src)
}
func (m *HealthCheckResponse) XXX_Size() int {
	return m.Size()
}
func (m *HealthCheckResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HealthCheckResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HealthCheckResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("bass.authentication.Constant_ErrorCode", Constant_ErrorCode_name, Constant_ErrorCode_value)
	proto.RegisterType((*Constant)(nil), "bass.authentication.Constant")
	proto.RegisterType((*EchoRequest)(nil), "bass.authentication.EchoRequest")
	proto.RegisterType((*EchoResponse)(nil), "bass.authentication.EchoResponse")
	proto.RegisterType((*VerifyEncryptedTokenRequest)(nil), "bass.authentication.VerifyEncryptedTokenRequest")
	proto.RegisterType((*VerifyEncryptedTokenResponse)(nil), "bass.authentication.VerifyEncryptedTokenResponse")
	proto.RegisterType((*UnpackEncryptedTokenRequest)(nil), "bass.authentication.UnpackEncryptedTokenRequest")
	proto.RegisterType((*UnpackEncryptedTokenResponse)(nil), "bass.authentication.UnpackEncryptedTokenResponse")
	proto.RegisterType((*GetUserInfoFromTokenRequest)(nil), "bass.authentication.GetUserInfoFromTokenRequest")
	proto.RegisterType((*GetUserInfoFromTokenResponse)(nil), "bass.authentication.GetUserInfoFromTokenResponse")
	proto.RegisterType((*GenerateEncryptedTokenRequest)(nil), "bass.authentication.GenerateEncryptedTokenRequest")
	proto.RegisterType((*GenerateEncryptedTokenResponse)(nil), "bass.authentication.GenerateEncryptedTokenResponse")
	proto.RegisterType((*KickOutUserRequest)(nil), "bass.authentication.KickOutUserRequest")
	proto.RegisterType((*KickOutUserResponse)(nil), "bass.authentication.KickOutUserResponse")
	proto.RegisterType((*ClearTokenVerificationCacheRequest)(nil), "bass.authentication.ClearTokenVerificationCacheRequest")
	proto.RegisterType((*ClearTokenVerificationCacheResponse)(nil), "bass.authentication.ClearTokenVerificationCacheResponse")
	proto.RegisterType((*GenerateEncryptedTobTokenRequest)(nil), "bass.authentication.GenerateEncryptedTobTokenRequest")
	proto.RegisterType((*GenerateEncryptedTobTokenResponse)(nil), "bass.authentication.GenerateEncryptedTobTokenResponse")
	proto.RegisterType((*UnpackEncryptedTobTokenRequest)(nil), "bass.authentication.UnpackEncryptedTobTokenRequest")
	proto.RegisterType((*UnpackEncryptedTobTokenResponse)(nil), "bass.authentication.UnpackEncryptedTobTokenResponse")
	proto.RegisterType((*VerifyTobTokenRequest)(nil), "bass.authentication.VerifyTobTokenRequest")
	proto.RegisterType((*VerifyTobTokenResponse)(nil), "bass.authentication.VerifyTobTokenResponse")
	proto.RegisterType((*KickOutTobUserRequest)(nil), "bass.authentication.KickOutTobUserRequest")
	proto.RegisterType((*KickOutTobUserResponse)(nil), "bass.authentication.KickOutTobUserResponse")
	proto.RegisterType((*ClearTobTokenVerificationCacheRequest)(nil), "bass.authentication.ClearTobTokenVerificationCacheRequest")
	proto.RegisterType((*ClearTobTokenVerificationCacheResponse)(nil), "bass.authentication.ClearTobTokenVerificationCacheResponse")
	proto.RegisterType((*HealthCheckRequest)(nil), "bass.authentication.HealthCheckRequest")
	proto.RegisterType((*HealthCheckResponse)(nil), "bass.authentication.HealthCheckResponse")
}

func init() { proto.RegisterFile("authentication.proto", fileDescriptor_d0dbc99083440df2) }

var fileDescriptor_d0dbc99083440df2 = []byte{
	// 987 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x56, 0x4b, 0x73, 0xdb, 0x54,
	0x14, 0x8e, 0x62, 0x27, 0x75, 0x4e, 0xfa, 0x50, 0x95, 0x38, 0x98, 0xc6, 0x55, 0x12, 0x95, 0xb4,
	0x59, 0x40, 0x57, 0x0c, 0x1b, 0x36, 0x38, 0xca, 0xad, 0x2d, 0xfc, 0x50, 0x46, 0x8f, 0x0c, 0x0c,
	0x0b, 0x8d, 0x6c, 0xdd, 0xc6, 0x9a, 0xc4, 0x92, 0x90, 0xae, 0x07, 0x3c, 0xc3, 0x82, 0x47, 0x79,
	0xc3, 0xc0, 0x96, 0x81, 0xbf, 0xc0, 0x86, 0x1d, 0xc3, 0x1f, 0xe8, 0xb2, 0x1b, 0x66, 0x58, 0x31,
	0x4c, 0xb2, 0x80, 0x1f, 0xc0, 0x0f, 0x60, 0xae, 0x74, 0x5d, 0x7c, 0x53, 0x25, 0x31, 0x05, 0x06,
	0xba, 0x3d, 0xdf, 0x77, 0xbf, 0x73, 0xce, 0xf7, 0x5d, 0x5f, 0x19, 0x96, 0xdd, 0x21, 0xe9, 0xe3,
	0x80, 0xf8, 0x3d, 0x97, 0xf8, 0x61, 0x70, 0x3b, 0x8a, 0x43, 0x12, 0x4a, 0x4b, 0x5d, 0x37, 0x49,
	0x6e, 0xf3, 0x90, 0xf2, 0x7b, 0x01, 0x4a, 0x6a, 0x18, 0x24, 0xc4, 0x0d, 0x88, 0xf2, 0x6b, 0x01,
	0x16, 0x50, 0x1c, 0x87, 0xb1, 0x1a, 0x7a, 0x58, 0x92, 0xe1, 0x29, 0x64, 0x18, 0xba, 0xe1, 0x68,
	0x9d, 0xbd, 0x5a, 0x4b, 0xdb, 0x71, 0x4c, 0x53, 0x77, 0x2c, 0xbd, 0x89, 0x3a, 0xe2, 0xdb, 0xdf,
	0x1e, 0x15, 0xa5, 0x6b, 0xb0, 0xc4, 0xe3, 0x19, 0xf6, 0x0e, 0xc5, 0xd6, 0xe1, 0x69, 0x1e, 0xb3,
	0x4d, 0x64, 0x38, 0xa6, 0x55, 0xb3, 0x6c, 0x53, 0x7c, 0x97, 0x32, 0x1e, 0xaa, 0xa3, 0x57, 0x76,
	0x35, 0x03, 0x4d, 0xaa, 0xbf, 0x47, 0xf1, 0x9b, 0xb0, 0xc6, 0x2b, 0xa8, 0xba, 0x81, 0x1c, 0x13,
	0x19, 0x7b, 0xc8, 0x60, 0xbc, 0x7b, 0x94, 0x57, 0x81, 0xab, 0x4c, 0xa7, 0xbd, 0x6b, 0xbd, 0xca,
	0x90, 0xf7, 0x29, 0x52, 0x85, 0x72, 0x86, 0xd8, 0x9d, 0x76, 0xcd, 0x52, 0x1b, 0x68, 0x3c, 0xe1,
	0x07, 0x1c, 0xca, 0x4d, 0xa8, 0xed, 0x88, 0x1f, 0xf2, 0x67, 0x69, 0xb5, 0xa9, 0xa9, 0x4d, 0xb4,
	0xe3, 0xe8, 0xb6, 0x25, 0x7e, 0x94, 0x3b, 0x1b, 0x25, 0xe8, 0xb6, 0xe5, 0x98, 0x5a, 0xbd, 0x53,
	0xb3, 0x6c, 0x03, 0x89, 0x1f, 0x53, 0xde, 0x0d, 0xa8, 0x66, 0xbc, 0xb6, 0x66, 0x9a, 0x5a, 0xa7,
	0xfe, 0x90, 0xa7, 0xea, 0x9d, 0x3b, 0x5a, 0x5d, 0xfc, 0x84, 0x92, 0xca, 0x70, 0x99, 0xb5, 0xda,
	0x35, 0x2d, 0x03, 0xd5, 0xda, 0xe2, 0xa7, 0x5c, 0x59, 0xeb, 0x58, 0xc8, 0xe8, 0xd4, 0x5a, 0xe2,
	0x67, 0x9c, 0x6d, 0x6a, 0x0b, 0xd5, 0x98, 0x11, 0x8e, 0x5a, 0x53, 0x1b, 0x48, 0xfc, 0x9c, 0xe2,
	0x9b, 0x20, 0x67, 0x78, 0x03, 0xd5, 0x5a, 0x56, 0xc3, 0x51, 0x1b, 0x48, 0x6d, 0x66, 0x04, 0x47,
	0x6d, 0xe9, 0xf6, 0x8e, 0xf8, 0xfd, 0x77, 0xbf, 0x15, 0x95, 0x5b, 0xb0, 0x88, 0x7a, 0xfd, 0xd0,
	0xc0, 0xaf, 0x0f, 0x71, 0x42, 0xa4, 0x0a, 0x14, 0x3d, 0x97, 0xb8, 0x15, 0x61, 0x5d, 0xd8, 0x2a,
	0x6e, 0x17, 0xef, 0xff, 0xbc, 0x36, 0x63, 0xa4, 0x15, 0x65, 0x0b, 0x2e, 0x66, 0xc4, 0x24, 0x0a,
	0x83, 0x04, 0x9f, 0xc1, 0x6c, 0xc1, 0xea, 0x1e, 0x8e, 0xfd, 0xbb, 0x23, 0x14, 0xf4, 0xe2, 0x51,
	0x44, 0xb0, 0x67, 0x85, 0x07, 0x38, 0x18, 0xb7, 0x78, 0x0e, 0xae, 0xe0, 0x31, 0xe0, 0x10, 0x8a,
	0xa4, 0x1a, 0x0b, 0x4c, 0xe3, 0x32, 0xe6, 0x4e, 0x29, 0x3f, 0x0a, 0x50, 0xcd, 0x97, 0x63, 0x83,
	0x5c, 0x83, 0xb9, 0x47, 0x55, 0xb2, 0x92, 0x74, 0x1d, 0x2e, 0x0c, 0x13, 0x1c, 0x3b, 0xbe, 0x57,
	0x99, 0x5d, 0x17, 0xb6, 0xe6, 0x18, 0x3a, 0x4f, 0x8b, 0x9a, 0x47, 0xe1, 0xa4, 0x1f, 0x46, 0x14,
	0x2e, 0x4c, 0xc2, 0xb4, 0xa8, 0x79, 0xd2, 0x06, 0x2c, 0xa4, 0xa7, 0x03, 0x77, 0x80, 0x2b, 0xc5,
	0x09, 0xf5, 0x12, 0x2d, 0x77, 0xdc, 0x41, 0xda, 0x1c, 0x0f, 0x5c, 0xff, 0xb0, 0x32, 0x37, 0xd9,
	0x3c, 0x2d, 0x49, 0x55, 0x98, 0x4f, 0x88, 0x4b, 0x86, 0x49, 0x65, 0x9e, 0x13, 0x4f, 0x6b, 0xca,
	0x3d, 0x01, 0x56, 0xed, 0x20, 0x72, 0x7b, 0x07, 0xff, 0x84, 0x4d, 0xd2, 0x0b, 0xb0, 0xec, 0xf9,
	0x89, 0xdb, 0x3d, 0xc4, 0x0e, 0x7e, 0x33, 0xf2, 0xe3, 0x91, 0xd3, 0xeb, 0xe3, 0xde, 0x41, 0xba,
	0x76, 0x89, 0x9d, 0x91, 0x18, 0x03, 0xa5, 0x04, 0x95, 0xe2, 0xca, 0xd7, 0x02, 0x54, 0xf3, 0xc7,
	0xf8, 0x1f, 0xd8, 0xab, 0x0c, 0x61, 0xb5, 0x8e, 0x89, 0x4d, 0xe5, 0x82, 0xbb, 0xe1, 0x9d, 0x38,
	0x1c, 0xfc, 0x1d, 0x8f, 0x6e, 0xc1, 0x45, 0xda, 0x1a, 0x63, 0xc6, 0x9d, 0x9d, 0xe0, 0x2e, 0x66,
	0xc8, 0x9f, 0x77, 0x2e, 0xbf, 0xef, 0x93, 0x7d, 0xe7, 0xbe, 0x11, 0xe0, 0x7a, 0x1d, 0x07, 0x38,
	0x76, 0x09, 0xce, 0xbf, 0x75, 0xff, 0x69, 0xda, 0x3a, 0xc8, 0xa7, 0x4d, 0xc7, 0x7c, 0xff, 0x8b,
	0x6f, 0x47, 0x13, 0xa4, 0xa6, 0xdf, 0x3b, 0xd0, 0x87, 0x69, 0x94, 0xe3, 0x1d, 0x27, 0xf6, 0x10,
	0x72, 0xf6, 0x58, 0x81, 0x42, 0xe2, 0xef, 0x73, 0x97, 0x83, 0x16, 0x94, 0x32, 0x2c, 0x71, 0x62,
	0xd9, 0x48, 0xca, 0x4b, 0xa0, 0xa8, 0x87, 0xd8, 0x8d, 0xd3, 0x8e, 0xe9, 0x43, 0xc5, 0xbe, 0xa8,
	0xaa, 0xdb, 0xeb, 0xe3, 0x29, 0x7c, 0x55, 0x36, 0xe1, 0xc6, 0x99, 0x0a, 0xac, 0xd1, 0x57, 0x02,
	0xac, 0xe7, 0xd8, 0xd3, 0xe5, 0xf2, 0xdb, 0x80, 0x05, 0x12, 0x76, 0x73, 0xac, 0x29, 0x11, 0xc6,
	0x94, 0x9e, 0x81, 0x45, 0x4a, 0x99, 0x8c, 0x72, 0xfc, 0x7e, 0xd3, 0xb3, 0x76, 0xe6, 0xc2, 0xb3,
	0x70, 0x85, 0xb2, 0xba, 0xc3, 0xc4, 0x0f, 0x70, 0x92, 0x8c, 0x53, 0xbd, 0xc4, 0x98, 0x97, 0x48,
	0xd8, 0xdd, 0x66, 0x98, 0xe6, 0x29, 0x6f, 0xc1, 0xc6, 0x19, 0xa3, 0xb1, 0xf0, 0x9e, 0x87, 0xa5,
	0xc9, 0xf0, 0xf2, 0xa6, 0xbc, 0x8a, 0x4f, 0x9e, 0xa6, 0x1b, 0x79, 0xb8, 0x3b, 0xdc, 0x77, 0x06,
	0x09, 0x1f, 0x4a, 0x29, 0x2d, 0xb7, 0x93, 0x7d, 0xe5, 0x0d, 0x90, 0x1f, 0x79, 0xc2, 0x78, 0x5b,
	0x1e, 0xaf, 0xf5, 0x1a, 0x94, 0xdc, 0x28, 0x72, 0xc8, 0x28, 0xc2, 0x69, 0xe7, 0xf1, 0xf2, 0x17,
	0xdc, 0x28, 0xb2, 0x46, 0x11, 0x56, 0x7e, 0x10, 0x60, 0xed, 0xd4, 0xce, 0x6c, 0x6b, 0x6e, 0x7e,
	0x21, 0x6f, 0x7e, 0x3e, 0xb4, 0xd9, 0x69, 0x42, 0x2b, 0x4c, 0x1d, 0x5a, 0xf1, 0xf4, 0xd0, 0x5e,
	0x83, 0x72, 0xf6, 0x61, 0x7d, 0x8c, 0x4b, 0x74, 0xae, 0x35, 0x5f, 0x08, 0xb0, 0x72, 0x52, 0x7d,
	0x7a, 0x47, 0xfe, 0x8d, 0x3b, 0x6a, 0x43, 0x99, 0xfd, 0x7e, 0xad, 0x4c, 0x61, 0xbc, 0xee, 0x89,
	0x66, 0x42, 0x7e, 0xb3, 0xd3, 0x9e, 0x85, 0x17, 0x61, 0xe5, 0xa4, 0xec, 0xd4, 0x7b, 0x2a, 0x2f,
	0xc3, 0x26, 0xfb, 0xe9, 0x77, 0xcf, 0x7e, 0x3f, 0xce, 0x8f, 0x44, 0x69, 0xc2, 0xcd, 0xf3, 0xb4,
	0xa6, 0x1f, 0x6c, 0x19, 0xa4, 0x06, 0x76, 0x0f, 0x49, 0x3f, 0xfd, 0x97, 0xc0, 0xa6, 0xa0, 0x4f,
	0x20, 0x57, 0xcd, 0xf4, 0xb6, 0x2b, 0xf7, 0x8f, 0x64, 0xe1, 0xc1, 0x91, 0x2c, 0xfc, 0x72, 0x24,
	0x0b, 0x5f, 0x1e, 0xcb, 0x33, 0x0f, 0x8e, 0xe5, 0x99, 0x9f, 0x8e, 0xe5, 0x99, 0x3f, 0x02, 0x00,
	0x00, 0xff, 0xff, 0xe6, 0xf5, 0xd3, 0x38, 0x80, 0x0c, 0x00, 0x00,
}

func (m *Constant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Constant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Constant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *EchoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EchoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EchoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintAuthentication(dAtA, i, uint64(m.Data))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *EchoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EchoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EchoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintAuthentication(dAtA, i, uint64(m.Data))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *VerifyEncryptedTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyEncryptedTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyEncryptedTokenRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.EncryptedToken)
	copy(dAtA[i:], m.EncryptedToken)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.EncryptedToken)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *VerifyEncryptedTokenResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyEncryptedTokenResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyEncryptedTokenResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintAuthentication(dAtA, i, uint64(m.Status))
	i--
	dAtA[i] = 0x30
	i -= len(m.Email)
	copy(dAtA[i:], m.Email)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.Email)))
	i--
	dAtA[i] = 0x2a
	i -= len(m.UserName)
	copy(dAtA[i:], m.UserName)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.UserName)))
	i--
	dAtA[i] = 0x22
	i = encodeVarintAuthentication(dAtA, i, uint64(m.ShopId))
	i--
	dAtA[i] = 0x18
	i = encodeVarintAuthentication(dAtA, i, uint64(m.UserId))
	i--
	dAtA[i] = 0x10
	i -= len(m.Token)
	copy(dAtA[i:], m.Token)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.Token)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *UnpackEncryptedTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnpackEncryptedTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnpackEncryptedTokenRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.DisableExpiryCheck {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	i -= len(m.EncryptedToken)
	copy(dAtA[i:], m.EncryptedToken)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.EncryptedToken)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *UnpackEncryptedTokenResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnpackEncryptedTokenResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnpackEncryptedTokenResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.UserName)
	copy(dAtA[i:], m.UserName)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.UserName)))
	i--
	dAtA[i] = 0x22
	i = encodeVarintAuthentication(dAtA, i, uint64(m.ShopId))
	i--
	dAtA[i] = 0x18
	i = encodeVarintAuthentication(dAtA, i, uint64(m.UserId))
	i--
	dAtA[i] = 0x10
	i -= len(m.Token)
	copy(dAtA[i:], m.Token)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.Token)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GetUserInfoFromTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserInfoFromTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUserInfoFromTokenRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.ShopeeToken)
	copy(dAtA[i:], m.ShopeeToken)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.ShopeeToken)))
	i--
	dAtA[i] = 0x12
	i -= len(m.EncryptedToken)
	copy(dAtA[i:], m.EncryptedToken)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.EncryptedToken)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GetUserInfoFromTokenResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserInfoFromTokenResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetUserInfoFromTokenResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintAuthentication(dAtA, i, uint64(m.Status))
	i--
	dAtA[i] = 0x30
	i -= len(m.Email)
	copy(dAtA[i:], m.Email)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.Email)))
	i--
	dAtA[i] = 0x2a
	i -= len(m.UserName)
	copy(dAtA[i:], m.UserName)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.UserName)))
	i--
	dAtA[i] = 0x22
	i = encodeVarintAuthentication(dAtA, i, uint64(m.ShopId))
	i--
	dAtA[i] = 0x18
	i = encodeVarintAuthentication(dAtA, i, uint64(m.UserId))
	i--
	dAtA[i] = 0x10
	i -= len(m.Token)
	copy(dAtA[i:], m.Token)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.Token)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GenerateEncryptedTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateEncryptedTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenerateEncryptedTokenRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.UserName)
	copy(dAtA[i:], m.UserName)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.UserName)))
	i--
	dAtA[i] = 0x22
	i = encodeVarintAuthentication(dAtA, i, uint64(m.ShopId))
	i--
	dAtA[i] = 0x18
	i = encodeVarintAuthentication(dAtA, i, uint64(m.UserId))
	i--
	dAtA[i] = 0x10
	i -= len(m.Token)
	copy(dAtA[i:], m.Token)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.Token)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GenerateEncryptedTokenResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateEncryptedTokenResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenerateEncryptedTokenResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.EncryptedToken)
	copy(dAtA[i:], m.EncryptedToken)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.EncryptedToken)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *KickOutUserRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KickOutUserRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KickOutUserRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Sig)
	copy(dAtA[i:], m.Sig)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.Sig)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintAuthentication(dAtA, i, uint64(m.UserId))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *KickOutUserResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KickOutUserResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KickOutUserResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ClearTokenVerificationCacheRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearTokenVerificationCacheRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearTokenVerificationCacheRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Token)
	copy(dAtA[i:], m.Token)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.Token)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ClearTokenVerificationCacheResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearTokenVerificationCacheResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearTokenVerificationCacheResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GenerateEncryptedTobTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateEncryptedTobTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenerateEncryptedTobTokenRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintAuthentication(dAtA, i, uint64(m.TobBusinessId))
	i--
	dAtA[i] = 0x18
	i = encodeVarintAuthentication(dAtA, i, uint64(m.TobUserId))
	i--
	dAtA[i] = 0x10
	i -= len(m.TobToken)
	copy(dAtA[i:], m.TobToken)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.TobToken)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GenerateEncryptedTobTokenResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateEncryptedTobTokenResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenerateEncryptedTobTokenResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.DebugMsg)
	copy(dAtA[i:], m.DebugMsg)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.DebugMsg)))
	i--
	dAtA[i] = 0x12
	i -= len(m.EncryptedTobToken)
	copy(dAtA[i:], m.EncryptedTobToken)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.EncryptedTobToken)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *UnpackEncryptedTobTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnpackEncryptedTobTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnpackEncryptedTobTokenRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintAuthentication(dAtA, i, uint64(m.AppType))
	i--
	dAtA[i] = 0x10
	i -= len(m.EncryptedTobToken)
	copy(dAtA[i:], m.EncryptedTobToken)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.EncryptedTobToken)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *UnpackEncryptedTobTokenResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnpackEncryptedTobTokenResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnpackEncryptedTobTokenResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintAuthentication(dAtA, i, uint64(m.TobBusinessId))
	i--
	dAtA[i] = 0x20
	i = encodeVarintAuthentication(dAtA, i, uint64(m.TobUserId))
	i--
	dAtA[i] = 0x18
	i -= len(m.TobToken)
	copy(dAtA[i:], m.TobToken)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.TobToken)))
	i--
	dAtA[i] = 0x12
	i -= len(m.DebugMsg)
	copy(dAtA[i:], m.DebugMsg)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.DebugMsg)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *VerifyTobTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyTobTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyTobTokenRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintAuthentication(dAtA, i, uint64(m.AppType))
	i--
	dAtA[i] = 0x10
	i -= len(m.TobToken)
	copy(dAtA[i:], m.TobToken)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.TobToken)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *VerifyTobTokenResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyTobTokenResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyTobTokenResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintAuthentication(dAtA, i, uint64(m.TobBusinessId))
	i--
	dAtA[i] = 0x18
	i = encodeVarintAuthentication(dAtA, i, uint64(m.TobUserId))
	i--
	dAtA[i] = 0x10
	i -= len(m.DebugMsg)
	copy(dAtA[i:], m.DebugMsg)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.DebugMsg)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *KickOutTobUserRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KickOutTobUserRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KickOutTobUserRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Sig)
	copy(dAtA[i:], m.Sig)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.Sig)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintAuthentication(dAtA, i, uint64(m.TobUserId))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *KickOutTobUserResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KickOutTobUserResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KickOutTobUserResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.DebugMsg)
	copy(dAtA[i:], m.DebugMsg)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.DebugMsg)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ClearTobTokenVerificationCacheRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearTobTokenVerificationCacheRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearTobTokenVerificationCacheRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.TobToken)
	copy(dAtA[i:], m.TobToken)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.TobToken)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ClearTobTokenVerificationCacheResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearTobTokenVerificationCacheResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearTobTokenVerificationCacheResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.DebugMsg)
	copy(dAtA[i:], m.DebugMsg)
	i = encodeVarintAuthentication(dAtA, i, uint64(len(m.DebugMsg)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *HealthCheckRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheckRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HealthCheckRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *HealthCheckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HealthCheckResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HealthCheckResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintAuthentication(dAtA []byte, offset int, v uint64) int {
	offset -= sovAuthentication(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Constant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *EchoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovAuthentication(uint64(m.Data))
	return n
}

func (m *EchoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovAuthentication(uint64(m.Data))
	return n
}

func (m *VerifyEncryptedTokenRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EncryptedToken)
	n += 1 + l + sovAuthentication(uint64(l))
	return n
}

func (m *VerifyEncryptedTokenResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	n += 1 + l + sovAuthentication(uint64(l))
	n += 1 + sovAuthentication(uint64(m.UserId))
	n += 1 + sovAuthentication(uint64(m.ShopId))
	l = len(m.UserName)
	n += 1 + l + sovAuthentication(uint64(l))
	l = len(m.Email)
	n += 1 + l + sovAuthentication(uint64(l))
	n += 1 + sovAuthentication(uint64(m.Status))
	return n
}

func (m *UnpackEncryptedTokenRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EncryptedToken)
	n += 1 + l + sovAuthentication(uint64(l))
	n += 2
	return n
}

func (m *UnpackEncryptedTokenResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	n += 1 + l + sovAuthentication(uint64(l))
	n += 1 + sovAuthentication(uint64(m.UserId))
	n += 1 + sovAuthentication(uint64(m.ShopId))
	l = len(m.UserName)
	n += 1 + l + sovAuthentication(uint64(l))
	return n
}

func (m *GetUserInfoFromTokenRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EncryptedToken)
	n += 1 + l + sovAuthentication(uint64(l))
	l = len(m.ShopeeToken)
	n += 1 + l + sovAuthentication(uint64(l))
	return n
}

func (m *GetUserInfoFromTokenResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	n += 1 + l + sovAuthentication(uint64(l))
	n += 1 + sovAuthentication(uint64(m.UserId))
	n += 1 + sovAuthentication(uint64(m.ShopId))
	l = len(m.UserName)
	n += 1 + l + sovAuthentication(uint64(l))
	l = len(m.Email)
	n += 1 + l + sovAuthentication(uint64(l))
	n += 1 + sovAuthentication(uint64(m.Status))
	return n
}

func (m *GenerateEncryptedTokenRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	n += 1 + l + sovAuthentication(uint64(l))
	n += 1 + sovAuthentication(uint64(m.UserId))
	n += 1 + sovAuthentication(uint64(m.ShopId))
	l = len(m.UserName)
	n += 1 + l + sovAuthentication(uint64(l))
	return n
}

func (m *GenerateEncryptedTokenResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EncryptedToken)
	n += 1 + l + sovAuthentication(uint64(l))
	return n
}

func (m *KickOutUserRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovAuthentication(uint64(m.UserId))
	l = len(m.Sig)
	n += 1 + l + sovAuthentication(uint64(l))
	return n
}

func (m *KickOutUserResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ClearTokenVerificationCacheRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	n += 1 + l + sovAuthentication(uint64(l))
	return n
}

func (m *ClearTokenVerificationCacheResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GenerateEncryptedTobTokenRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TobToken)
	n += 1 + l + sovAuthentication(uint64(l))
	n += 1 + sovAuthentication(uint64(m.TobUserId))
	n += 1 + sovAuthentication(uint64(m.TobBusinessId))
	return n
}

func (m *GenerateEncryptedTobTokenResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EncryptedTobToken)
	n += 1 + l + sovAuthentication(uint64(l))
	l = len(m.DebugMsg)
	n += 1 + l + sovAuthentication(uint64(l))
	return n
}

func (m *UnpackEncryptedTobTokenRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EncryptedTobToken)
	n += 1 + l + sovAuthentication(uint64(l))
	n += 1 + sovAuthentication(uint64(m.AppType))
	return n
}

func (m *UnpackEncryptedTobTokenResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DebugMsg)
	n += 1 + l + sovAuthentication(uint64(l))
	l = len(m.TobToken)
	n += 1 + l + sovAuthentication(uint64(l))
	n += 1 + sovAuthentication(uint64(m.TobUserId))
	n += 1 + sovAuthentication(uint64(m.TobBusinessId))
	return n
}

func (m *VerifyTobTokenRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TobToken)
	n += 1 + l + sovAuthentication(uint64(l))
	n += 1 + sovAuthentication(uint64(m.AppType))
	return n
}

func (m *VerifyTobTokenResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DebugMsg)
	n += 1 + l + sovAuthentication(uint64(l))
	n += 1 + sovAuthentication(uint64(m.TobUserId))
	n += 1 + sovAuthentication(uint64(m.TobBusinessId))
	return n
}

func (m *KickOutTobUserRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovAuthentication(uint64(m.TobUserId))
	l = len(m.Sig)
	n += 1 + l + sovAuthentication(uint64(l))
	return n
}

func (m *KickOutTobUserResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DebugMsg)
	n += 1 + l + sovAuthentication(uint64(l))
	return n
}

func (m *ClearTobTokenVerificationCacheRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TobToken)
	n += 1 + l + sovAuthentication(uint64(l))
	return n
}

func (m *ClearTobTokenVerificationCacheResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DebugMsg)
	n += 1 + l + sovAuthentication(uint64(l))
	return n
}

func (m *HealthCheckRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *HealthCheckResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovAuthentication(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAuthentication(x uint64) (n int) {
	return sovAuthentication(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Constant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Constant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Constant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EchoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EchoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EchoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			m.Data = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Data |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EchoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EchoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EchoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			m.Data = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Data |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyEncryptedTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyEncryptedTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyEncryptedTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyEncryptedTokenResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyEncryptedTokenResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyEncryptedTokenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopId", wireType)
			}
			m.ShopId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnpackEncryptedTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnpackEncryptedTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnpackEncryptedTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableExpiryCheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableExpiryCheck = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnpackEncryptedTokenResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnpackEncryptedTokenResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnpackEncryptedTokenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopId", wireType)
			}
			m.ShopId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserInfoFromTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserInfoFromTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserInfoFromTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopeeToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShopeeToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserInfoFromTokenResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserInfoFromTokenResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserInfoFromTokenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopId", wireType)
			}
			m.ShopId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateEncryptedTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateEncryptedTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateEncryptedTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShopId", wireType)
			}
			m.ShopId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShopId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateEncryptedTokenResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateEncryptedTokenResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateEncryptedTokenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KickOutUserRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KickOutUserRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KickOutUserRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KickOutUserResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KickOutUserResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KickOutUserResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearTokenVerificationCacheRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearTokenVerificationCacheRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearTokenVerificationCacheRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearTokenVerificationCacheResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearTokenVerificationCacheResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearTokenVerificationCacheResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateEncryptedTobTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateEncryptedTobTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateEncryptedTobTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TobToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TobToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TobUserId", wireType)
			}
			m.TobUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TobUserId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TobBusinessId", wireType)
			}
			m.TobBusinessId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TobBusinessId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateEncryptedTobTokenResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateEncryptedTobTokenResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateEncryptedTobTokenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedTobToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedTobToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DebugMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnpackEncryptedTobTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnpackEncryptedTobTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnpackEncryptedTobTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedTobToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedTobToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppType", wireType)
			}
			m.AppType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnpackEncryptedTobTokenResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnpackEncryptedTobTokenResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnpackEncryptedTobTokenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DebugMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TobToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TobToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TobUserId", wireType)
			}
			m.TobUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TobUserId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TobBusinessId", wireType)
			}
			m.TobBusinessId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TobBusinessId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyTobTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyTobTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyTobTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TobToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TobToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppType", wireType)
			}
			m.AppType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyTobTokenResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyTobTokenResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyTobTokenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DebugMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TobUserId", wireType)
			}
			m.TobUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TobUserId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TobBusinessId", wireType)
			}
			m.TobBusinessId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TobBusinessId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KickOutTobUserRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KickOutTobUserRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KickOutTobUserRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TobUserId", wireType)
			}
			m.TobUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TobUserId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KickOutTobUserResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KickOutTobUserResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KickOutTobUserResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DebugMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearTobTokenVerificationCacheRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearTobTokenVerificationCacheRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearTobTokenVerificationCacheRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TobToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TobToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearTobTokenVerificationCacheResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearTobTokenVerificationCacheResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearTobTokenVerificationCacheResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthentication
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthentication
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DebugMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheckRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthCheckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthCheckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HealthCheckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HealthCheckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HealthCheckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAuthentication(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAuthentication
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAuthentication(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAuthentication
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuthentication
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAuthentication
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAuthentication
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAuthentication
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAuthentication        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAuthentication          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAuthentication = fmt.Errorf("proto: unexpected end of group")
)
